"""Created on Wed Feb 16 2022@author: aidangross"""### CODE LAST UPDATED 3/23/2022 By: Aidan Gross #### This script will import the excel exports from actilife. These files# contain the chronological time stamped HR data. Specifically, these actilife# exports contain the time duration between every RR interval captured while # the subject was wearing the monitor # This script is centered around calculating and exporting features from the # time domain however, the frequency domain metrics can also be calculated # using the hrv-analysis module. # To start we import the data from actilife and manipulate it such that we# may feed it into the hrv-analysis module for time domain calculations. import numpy as npimport pandas as pdimport matplotlib.pyplot as pltfrom typing import Listfrom matplotlib import stylefrom matplotlib.patches import Ellipsefrom hrvanalysis.extract_features import _get_freq_psd_from_nn_intervalsfrom hrvanalysis.extract_features import get_poincare_plot_featuresfrom collections import namedtuplesubject_id = input('Enter Subject ID e.g. OP3_S#_V#: ')filename = subject_id+'_rr_export.xlsx'filepath = '/Users/aidangross/Desktop/oofos_actigraph_analysis/oofos_hr_analysis/oofos_hr_exports/'hr_import = filepath+filenameX = pd.read_excel(hr_import,header=1, skiprows=0)rr_int_series = X['RR Interval in seconds']rr_int = pd.to_numeric(rr_int_series)hr_data_series = X['Heart Rate']hr_data = pd.to_numeric(hr_data_series)time_stamp= X['Timestamp'].astype(str).values.tolist()day_1_rr=[]day_1_hr=[]for (index,d) in enumerate(time_stamp):    if '2021-10-02' in d:        day_1_rr.append(rr_int[index])        day_1_hr.append(hr_data[index])    else:        pass    ### Day of Interest ###rr_intervals_array1 = np.array(day_1_rr)rr_intervals_list1 = rr_intervals_array1*1000rr_intervals_list_int1 = rr_intervals_list1.astype(int)## The following section of codes is for cleaning and interpolating the code ## from hrvanalysis import remove_outliers, remove_ectopic_beats, interpolate_nan_values# rr_intervals_list contains integer values of RR-interval #subject_rr_intervals_list = rr_intervals_list_int1# This remove outliers from signal #rr_intervals_without_outliers = remove_outliers(rr_intervals=subject_rr_intervals_list,                                                  low_rri=300, high_rri=2000)# This replace outliers nan values with linear interpolation #interpolated_rr_intervals = interpolate_nan_values(rr_intervals=rr_intervals_without_outliers,                                                   interpolation_method="linear")# This remove ectopic beats from signal #nn_intervals_list = remove_ectopic_beats(rr_intervals=interpolated_rr_intervals, method="kamath")# This replace ectopic beats nan values with linear interpolation #interpolated_nn_intervals = interpolate_nan_values(rr_intervals=nn_intervals_list,interpolation_method="linear")interpolated_nn_intervals = np.array(interpolated_nn_intervals,dtype=int)from hrvanalysis import get_time_domain_featurestime_domain_features = get_time_domain_features(interpolated_nn_intervals)print(time_domain_features)from hrvanalysis import get_frequency_domain_featuresfrequency_domain_features = get_frequency_domain_features(interpolated_nn_intervals)print(frequency_domain_features)##################################### PLOTTING #################################################################### Plotting Code Sourced From: ##################################################    # https://github.com/Aura-healthcare/hrv-analysis/blob/master/hrvanalysis/plot.py ## Named Tuple for different frequency bands #VlfBand = namedtuple("Vlf_band", ["low", "high"])LfBand = namedtuple("Lf_band", ["low", "high"])HfBand = namedtuple("Hf_band", ["low", "high"])#################################################################################################def plot_psd_mobl(nn_intervals: List[float], method: str = "welch", sampling_frequency: int = 7,             interpolation_method: str = "linear", vlf_band: namedtuple = VlfBand(0.003, 0.04),             lf_band: namedtuple = LfBand(0.04, 0.15), hf_band: namedtuple = HfBand(0.15, 0.40)):    """    Function plotting the power spectral density of the NN Intervals.    Arguments    ---------    nn_intervals : list        list of Normal to Normal Interval.    method : str        Method used to calculate the psd. Choice are Welch's FFT (welch) or Lomb method (lomb).    sampling_frequency : int        frequence at which the signal is sampled. Common value range from 1 Hz to 10 Hz, by default        set to 7 Hz. No need to specify if Lomb method is used.    interpolation_method : str        kind of interpolation as a string, by default "linear". No need to specify if lomb method is        used.    vlf_band : tuple        Very low frequency bands for features extraction from power spectral density.    lf_band : tuple        Low frequency bands for features extraction from power spectral density.    hf_band : tuple        High frequency bands for features extraction from power spectral density.    """    freq, psd = _get_freq_psd_from_nn_intervals(nn_intervals=nn_intervals, method=method,                                                sampling_frequency=sampling_frequency,                                                interpolation_method=interpolation_method)    # Calcul of indices between desired frequency bands    vlf_indexes = np.logical_and(freq >= vlf_band[0], freq < vlf_band[1])    lf_indexes = np.logical_and(freq >= lf_band[0], freq < lf_band[1])    hf_indexes = np.logical_and(freq >= hf_band[0], freq < hf_band[1])    frequency_band_index = [vlf_indexes, lf_indexes, hf_indexes]    label_list = ["VLF component", "LF component", "HF component"]    # Plot parameters    style.use("seaborn-darkgrid")    plt.figure(figsize=(12, 8))    plt.xlabel("Frequency (Hz)", fontsize=15)    plt.ylabel("PSD (s2/ Hz)", fontsize=15)    if method == "lomb":        plt.title("Lomb's periodogram", fontsize=20)        for band_index, label in zip(frequency_band_index, label_list):            plt.fill_between(freq[band_index], 0, psd[band_index] / (1000 * len(psd[band_index])), label=label)        plt.legend(prop={"size": 15}, loc="best")    elif method == "welch":        plt.title("FFT Spectrum : Welch's periodogram", fontsize=20)        for band_index, label in zip(frequency_band_index, label_list):            plt.fill_between(freq[band_index], 0, psd[band_index] / (1000 * len(psd[band_index])), label=label)        plt.legend(prop={"size": 15}, loc="best")        plt.xlim(0, hf_band[1])    else:        raise ValueError("Not a valid method. Choose between 'lomb' and 'welch'")###############################################################################################plot_psd_mobl(interpolated_nn_intervals, method="lomb")plot_psd_mobl(interpolated_nn_intervals, method="welch")###############################################################################################def plot_poincare_mobl(nn_intervals: List[float], plot_sd_features: bool = True):    """    Pointcare / Lorentz Plot of the NN Intervals    Arguments    ---------    nn_intervals : list        list of NN intervals    plot_sd_features : bool        Option to show or not SD1 and SD2 features on plot. By default, set to True.    Notes    ---------    The transverse axis (T) reflects beat-to-beat variation    the longitudinal axis (L) reflects the overall fluctuation    """    # For Lorentz / poincaré Plot    ax1 = nn_intervals[:-1]    ax2 = nn_intervals[1:]    # compute features for ellipse's height, width and center    dict_sd1_sd2 = get_poincare_plot_features(nn_intervals)    sd1 = dict_sd1_sd2["sd1"]    sd2 = dict_sd1_sd2["sd2"]    mean_nni = np.mean(nn_intervals)    # Plot options and settings    style.use("seaborn-darkgrid")    fig = plt.figure(figsize=(12, 12))    ax = fig.add_subplot(111)    plt.title("Poincaré / Lorentz Plot", fontsize=20)    plt.xlabel('NN_n (s)', fontsize=15)    plt.ylabel('NN_n+1 (s)', fontsize=15)    plt.xlim(min(nn_intervals) - 10, max(nn_intervals) + 10)    plt.ylim(min(nn_intervals) - 10, max(nn_intervals) + 10)    # Poincaré Plot    ax.scatter(ax1, ax2, c='b', s=2)    if plot_sd_features:        # Ellipse plot settings        ells = Ellipse(xy=(mean_nni, mean_nni), width=2 * sd2 + 1,                       height=2 * sd1 + 1, angle=45, linewidth=2,                       fill=False)        ax.add_patch(ells)        ells = Ellipse(xy=(mean_nni, mean_nni), width=2 * sd2,                       height=2 * sd1, angle=45)        ells.set_alpha(0.05)        ells.set_facecolor("blue")        ax.add_patch(ells)        # Arrow plot settings        sd1_arrow = ax.arrow(mean_nni, mean_nni, -sd1 * np.sqrt(2) / 2, sd1 * np.sqrt(2) / 2,                             linewidth=3, ec='r', fc="r", label="SD1")        sd2_arrow = ax.arrow(mean_nni, mean_nni, sd2 * np.sqrt(2) / 2, sd2 * np.sqrt(2) / 2,                             linewidth=3, ec='g', fc="g", label="SD2")        plt.legend(handles=[sd1_arrow, sd2_arrow], fontsize=12, loc="best")        ################################################################################################plot_poincare_mobl(interpolated_nn_intervals, plot_sd_features=True)##################################### EXPORTING ################################################### Exporting time and frequency domain features to subject specific excel sheet ###def merge_dictionaries(a, b):    return {**a, **b}d = merge_dictionaries(time_domain_features, frequency_domain_features)print(d)df_features = pd.DataFrame.from_dict(d, orient='index', columns=['feature values'])print(df_features)df_features.to_excel(subject_id+'_features_export.xlsx')### Exporting and saving subject specific hrv plots to a pdf document in the current path ###from matplotlib.backends.backend_pdf import PdfPagesdef save_multi_image(export):    pp = PdfPages(export)    fig_nums = plt.get_fignums()    figs = [plt.figure(n) for n in fig_nums]    for fig in figs:      fig.savefig(pp, format='pdf')    pp.close()export = subject_id+"_hrv_plots.pdf"save_multi_image(export)plt.show()plt.show()plt.show() 